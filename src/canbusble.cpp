/******************************************************************************

  DucatiPanigaleCanBus

  Monitor CANBUS messages and report them to HLT: this code is specialized for
  messages generated by the Mitsubishi ECU used in some models like
  - Panigale (899/959/1199/1199S/1199R/1299/1299S/R and Superleggera)
  - Multistrada 1200 (2010 to 2014)
  - Diavel, Diavel Strada, Diavel DS
  
  Testing is done on a Panigale 899 right now, please report testing on other
  models at https://github.com/renatobo/DucatiPanigaleCanBus/issues 

  More info at https://github.com/renatobo/DucatiPanigaleCanBus
  Renato Bonomini https://github.com/renatobo

******************************************************************************/

#include <Arduino.h>
// Define the connections used by your ESP32 in the pinout file
#include "canbusble_pinout.h"

// Name used as prefix or name for BLE, WiFi, OTA hostname
#define DEVICE_ID "DuCan"

// Define the PIN requested by Bluetooth Pairing for bonding
#define BLE_SECURITY_PASS 123456

// Scheduler for periodic tasks, from arkhipenko/TaskScheduler
#include <TaskScheduler.h>
Scheduler ts;

// Troubleshooting options
//
// Define the macro CAN_DATA_SIMULATOR_MODE to generate linear looping values for counters instead of reading from CANBUS
// The better option is to use a compile time define (see platformio.ini for an example)
// #define CAN_DATA_SIMULATOR_MODE

/* ----------- CANBUS definitions ------------- */
#include "CAN.h"
#define RX_TASK_PRIO 9
#define LOGTAG "CAN Listen Only"

// In this code we look at 3 messages, this is the list of CANBUS ID's
#define ID_FRAME80 0x80
#define ID_FRAME100 0x100
#define ID_FRAME18 0x18

/* ------ counters for informational and debug purposes ----- */
uint32_t counter_18;
uint32_t counter_80;
uint32_t counter_100;

// Structure to hold "fast frequency" messages type 1 (rpm, wheelspeed, tps, gear)
#define BLE_FASTTASK_INTERVAL 50
#define CANBUS_FASTMSG_TYPE 1
#define CANBUS_MSGTYPE1_SIZE 7
#define CANBUS_FAST_SIZE CANBUS_MSGTYPE1_SIZE
typedef struct
{
  const uint8_t msgtype = CANBUS_FASTMSG_TYPE;
  uint16_t rpm;
  uint16_t rearwheelspeed;
  uint8_t aps;
  int8_t gear;
} canbus_msgtype1_t;

canbus_msgtype1_t message_fast;
uint8_t ble_msg_fast[CANBUS_FAST_SIZE];

// Structure to hold "slow frequency" messages type 2 (enginetemperature, ambientemperature, battery)
#define BLE_SLOWTASK_INTERVAL 1000
#define CANBUS_SLOWMSG_TYPE 2
#define CANBUS_SLOW_SIZE CANBUS_MSGTYPE2_SIZE
#define CANBUS_MSGTYPE2_SIZE 4
typedef struct
{
  const uint8_t msgtype = CANBUS_SLOWMSG_TYPE;
  uint8_t enginetemp;
  uint8_t ambientemp;
  uint8_t battery;
} canbus_msgtype2_t;

canbus_msgtype2_t message_slow;
uint8_t ble_msg_slow[CANBUS_SLOW_SIZE];

/* ---------------------    Utilities    ------------------ */
bool ledstatus;
void status_led_flip()
{
  ledstatus = !ledstatus;
  digitalWrite(LED_STATUS, (ledstatus ? HIGH : LOW)); // set pin to the opposite state
}

/* --------------------- BLE Definitions ------------------ */
#include <NimBLEDevice.h>

// Random UUID's, matched in the LUA Script
#define BLE_ENGINEDATA_SERVICE_UUID "6E400001-59f2-4a41-9acd-cd56fb435d64"
#define BLE_SLOW_ENGINEDATA_CHARACTERISTIC_UUID "6E400011-59f2-4a41-9acd-cd56fb435d64"
#define BLE_FAST_ENGINEDATA_CHARACTERISTIC_UUID "6E400012-59f2-4a41-9acd-cd56fb435d64"
#define BLE_REBOOT_CHARACTERISTIC_UUID "6E400012-59f2-4a41-9acd-cd56fb435000"
#define BLE_DEVICE_ID_PREFIX DEVICE_ID

static NimBLEServer *pServer;
NimBLECharacteristic *pFastCharacteristic = NULL;
NimBLECharacteristic *pSlowCharacteristic = NULL;
NimBLECharacteristic *pRebootCharacteristic = NULL;
bool BLEdeviceConnected = false;

// notify a fast frequency message
void handle_ble_notify_msg_fast()
{
  if (BLEdeviceConnected)
  {
    memcpy(ble_msg_fast + sizeof message_fast.msgtype, &message_fast.rpm, sizeof message_fast.rpm);
    memcpy(ble_msg_fast + sizeof message_fast.msgtype + sizeof message_fast.rpm, &message_fast.rearwheelspeed, sizeof message_fast.rearwheelspeed);
    memcpy(ble_msg_fast + sizeof message_fast.msgtype + sizeof message_fast.rpm + sizeof message_fast.rearwheelspeed, &message_fast.aps, sizeof message_fast.aps);
    memcpy(ble_msg_fast + sizeof message_fast.msgtype + sizeof message_fast.rpm + sizeof message_fast.rearwheelspeed + sizeof message_fast.aps, &message_fast.gear, sizeof message_fast.gear);

    pFastCharacteristic->setValue(ble_msg_fast, CANBUS_FAST_SIZE);
    pFastCharacteristic->notify();
  }
}
Task tNotify_fast(BLE_FASTTASK_INTERVAL, -1, &handle_ble_notify_msg_fast, &ts, false);

// notify a slow frequency message
void handle_ble_notify_msg_slow()
{
  if (BLEdeviceConnected)
  {
    memcpy(ble_msg_slow + sizeof message_slow.msgtype, &message_slow.enginetemp, sizeof message_slow.enginetemp);
    memcpy(ble_msg_slow + sizeof message_slow.msgtype + sizeof message_slow.enginetemp, &message_slow.ambientemp, sizeof message_slow.ambientemp);
    memcpy(ble_msg_slow + sizeof message_slow.msgtype + sizeof message_slow.enginetemp + sizeof message_slow.ambientemp, &message_slow.battery, sizeof message_slow.battery);

    pSlowCharacteristic->setValue(ble_msg_slow, CANBUS_SLOW_SIZE);
    pSlowCharacteristic->notify();
  }
}
Task tNotify_slow(BLE_SLOWTASK_INTERVAL, -1, &handle_ble_notify_msg_slow, &ts, false);

// BLE CallBacks
class MyServerCallbacks : public NimBLEServerCallbacks
{
  void onConnect(NimBLEServer *pServer)
  {
    BLEdeviceConnected = true;
    log_i("Client connected");
    // NimBLEDevice::startAdvertising();
  };

  void onConnect(NimBLEServer *pServer, ble_gap_conn_desc *desc)
  {
    BLEdeviceConnected = true;
    log_i("Client address: %s", NimBLEAddress(desc->peer_ota_addr).toString().c_str());
    // NimBLEDevice::stopAdvertising();
  }

  void onDisconnect(NimBLEServer *pServer)
  {
    BLEdeviceConnected = false;
    tNotify_fast.disable();
    tNotify_slow.disable();
    log_i("Client disconnected - start advertising");
    // NimBLEDevice::startAdvertising();
  }
};
class MyCharacteristicCallbacks : public NimBLECharacteristicCallbacks
{
  void onSubscribe(NimBLECharacteristic *pCharacteristic, ble_gap_conn_desc *desc, uint16_t subValue)
  {
#if (CORE_DEBUG_LEVEL > 0)
    // Be verbose on client subscription activity when debug level is not null
    String logmessage = "Client ID: ";
    logmessage += desc->conn_handle;
    logmessage += " Address: ";
    logmessage += std::string(NimBLEAddress(desc->peer_ota_addr)).c_str();
    if (subValue == 0)
    {
      logmessage += " Unsubscribed to ";
    }
    else if (subValue == 1)
    {
      logmessage += " Subscribed to notifications for ";
    }
    else if (subValue == 2)
    {
      logmessage += " Subscribed to indications for ";
    }
    else if (subValue == 3)
    {
      logmessage += " Subscribed to notifications and indications for ";
    }
    logmessage += std::string(pCharacteristic->getUUID()).c_str();
    log_i("New sub: %s", logmessage);
#endif
    // Start notifications when a client subscribes

    log_i("Initialize message version variables: FAST %d, SLOW %d", message_fast.msgtype, message_slow.msgtype);
    // Initialize the message type version, once.
    memcpy(ble_msg_fast, &message_fast.msgtype, sizeof message_fast.msgtype);
    memcpy(ble_msg_slow, &message_slow.msgtype, sizeof message_slow.msgtype);

    // HLT normalizes APS input, so we trigger a MAX-MIN sequence to let us send 0-1 values later
    // Initialize APS to 1
    log_i("Prime APS normalization to 1-100");
    uint8_t aps_init = 1;
    memcpy(ble_msg_fast + sizeof message_fast.msgtype + sizeof message_fast.rpm + sizeof message_fast.rearwheelspeed, &aps_init, sizeof message_fast.aps);
    pFastCharacteristic->setValue(ble_msg_fast, CANBUS_FAST_SIZE);
    pFastCharacteristic->notify();
    delay(5);
    aps_init = 100;
    memcpy(ble_msg_fast + sizeof message_fast.msgtype + sizeof message_fast.rpm + sizeof message_fast.rearwheelspeed, &aps_init, sizeof message_fast.aps);
    pFastCharacteristic->setValue(ble_msg_fast, CANBUS_FAST_SIZE);
    pFastCharacteristic->notify();
    delay(5);

    tNotify_fast.enable();
    tNotify_slow.enable();
  };

  void onWrite(NimBLECharacteristic *pCharacteristic,ble_gap_conn_desc * 	desc ) {
    log_i("Characteristic %s, written value: %d",pCharacteristic->getUUID().toString().c_str(), pCharacteristic->getValue().c_str());
    if (pCharacteristic->getUUID() == pRebootCharacteristic->getUUID())
    {
      log_e("reboot");
      //TODO: this should be handled gently, not simply stop and reboot 
      NimBLEDevice::getServer()->disconnect(desc->conn_handle);
      ESP.restart();
    }
  };
};
static MyCharacteristicCallbacks chrCallbacks;

/* --------------------- CanBus Functions ------------------ */
#if !defined(CAN_DATA_SIMULATOR_MODE)
void onReceive(int packetSize)
{
  // received a packet
  long identifier = CAN.packetId();
  uint8_t message[packetSize];

  if (identifier == ID_FRAME80)
  {
    counter_80++;
    CAN.readBytes(message, packetSize);
    message_fast.aps = message[4] / 2;
    message_fast.rpm = ((uint16_t)message[5]) * 256 + (uint16_t)message[6];
  }
  else if (identifier == ID_FRAME18)
  {
    counter_18++;
    CAN.readBytes(message, packetSize);
    message_fast.rearwheelspeed = (((uint16_t)(message[4] & 0b00011111)) << 4) + (message[5] >> 4);
    message_fast.gear = message[4] / 32;
  }
  else if (identifier == ID_FRAME100)
  {
    counter_100++;
    CAN.readBytes(message, packetSize);
    message_slow.enginetemp = message[3] - 40;
    message_slow.ambientemp = message[5] - 40;
    message_slow.battery = message[4];
  }
}
#endif // #if !defined(CAN_DATA_SIMULATOR_MODE)

#if (CORE_DEBUG_LEVEL > 0)
// Pretty print a CANBUS message
bool to_hex(char *dest, size_t dest_len, const uint8_t *values, size_t val_len)
{
  // check that dest is large enough
  if (dest_len < (val_len * 2 + 1))
    return false;
  // in case val_len==0
  *dest = '\0';
  while (val_len--)
  {
    // sprintf directly to where dest points
    sprintf(dest, "%02X", *values);
    dest += 2;
    ++values;
  }
  return true;
}
#endif

uint8_t nodata_watchdog=0;
// amount in seconds to wait until a restart happens if no data is seen on the bus
// use a longer period if LAZYWATCHDOG defined
#ifndef LAZYWATCHDOG 
#define NODATA_WATCHDOG_TIMER (uint8_t) 10
#else 
#define NODATA_WATCHDOG_TIMER (uint8_t) 120
#endif

void report_msg_counters()
{
#if (CORE_DEBUG_LEVEL > 0)
  char slowmessagehex[sizeof(ble_msg_slow) * 2 + 1];
  to_hex(slowmessagehex, sizeof(slowmessagehex), ble_msg_slow, sizeof(ble_msg_slow));
  char fastmessagehex[sizeof(ble_msg_fast) * 2 + 1];
  to_hex(fastmessagehex, sizeof(fastmessagehex), ble_msg_fast, sizeof(ble_msg_fast));

  log_i("Counters [18: %d, 80: %d, 100: %d], values RPM: %d, Speed: %d, APS: %d, Gear: %d, ETemp: %d, ATemp %d, Battery: %d. SLOW [%s], FAST [%s]",
        counter_18, counter_80, counter_100,
        message_fast.rpm, message_fast.rearwheelspeed, message_fast.aps, message_fast.gear,
        message_slow.enginetemp, message_slow.ambientemp, message_slow.battery,
        slowmessagehex, fastmessagehex);
#endif
  status_led_flip();
  if (counter_18+counter_80+counter_100 == 0 && nodata_watchdog++>NODATA_WATCHDOG_TIMER) {
    log_e("no data observed - watchdog 'no data' rebooting device");
    // TODO: the BLE connection should be handled gently, not simply stop and reboot 
    ESP.restart();
  }
}
Task tReport(1000, -1, &report_msg_counters, &ts, true);

/* --------------------- Simulation Functions ------------------ */
#if defined(CAN_DATA_SIMULATOR_MODE)
// this goes from 0 to 100 then it resets
uint base_counter = 1;
const uint base_cycles = 1000;

void handle_dm_increase()
{
  // complete update in 100 cycles
  message_fast.rearwheelspeed = 5 + base_counter * (300 - 5) / base_cycles;
  message_fast.rpm = 2000 + base_counter * (12000 - 2000) / base_cycles;
  message_fast.aps = 1 + base_counter * 99 / base_cycles;
  message_fast.gear = 1 + base_counter * 5 / base_cycles;
  message_slow.enginetemp = 70 + base_counter * (110 - 70) / base_cycles;
  message_slow.ambientemp = 16 + base_counter * (40 - 16) / base_cycles;
  message_slow.battery = 120 + base_counter * (140 - 120) / base_cycles;
  if (base_counter++ > base_cycles)
    base_counter = 0;
  counter_18++;
  counter_80++;
  counter_100++;
}
Task tIncreaseDM(100, -1, &handle_dm_increase, &ts, true);

#endif

/* --------------------- Double Reset to start OTA via WiFi ------------------ */
#if defined(ESP32)
#define USE_SPIFFS false
#define ESP_DRD_USE_EEPROM true
#define ESP_DRD_USE_LITTLEFS false
#else
#error This code is intended to run on the ESP32 platform! Please check your Tools->Board setting.
#endif

#define DRD_TIMEOUT 5
#define DRD_ADDRESS 0
#include <ESP_DoubleResetDetector.h> //https://github.com/khoih-prog/ESP_DoubleResetDetector
DoubleResetDetector *drd;

// for OTA via TCP/IP
#include <WiFi.h>
#include <WiFiUdp.h>
#include <ArduinoOTA.h>
const char *password = "123456789";
#define OTA_TIMEOUT 120

/* ---------------------  Setup Loop  ------------------ */
void setup()
{
  // hold the device id to be used in broadcasting unit identifier strings
  const uint16_t chip = (uint16_t)((uint64_t)ESP.getEfuseMac() >> 32);
  // Generate device name based on mac address
  char ble_device_id[12];
  sprintf(ble_device_id, "%s-%04X", BLE_DEVICE_ID_PREFIX, chip);

  // Detect if a double reset was used to start OTA updates
  // Display reason for last restart
  esp_reset_reason_t last_reset_reason;
  last_reset_reason = esp_reset_reason();
  // enter_reconfig only if there was a valid reason
  bool enter_reconfig = false;
  switch (last_reset_reason)
  {
  case ESP_RST_UNKNOWN:
    log_w("Restarted because ESP_RST_UNKNOWN");
    break;
  case ESP_RST_POWERON:
    log_i("Restarted because ESP_RST_POWERON");
    break;
  case ESP_RST_SW:
    log_i("Restarted because ESP_RST_SW");
    enter_reconfig = true;
    break;
  case ESP_RST_PANIC:
    log_e("Restarted because ESP_RST_PANIC");
    break;
  case ESP_RST_INT_WDT:
    enter_reconfig = true;
    log_w("Restarted because ESP_RST_INT_WDT");
    break;
  case ESP_RST_TASK_WDT:
    enter_reconfig = true;
    log_w("Restarted because ESP_RST_TASK_WDT");
    break;
  case ESP_RST_WDT:
    enter_reconfig = true;
    log_w("Restarted because ESP_RST_WDT");
    break;
  case ESP_RST_DEEPSLEEP:
    log_i("Restarted because ESP_RST_DEEPSLEEP");
    break;
  case ESP_RST_BROWNOUT:
    log_w("Restarted because ESP_RST_BROWNOUT");
    delay(500);
    break;
  case ESP_RST_SDIO:
    log_i("Restarted because ESP_RST_SDIO");
    break;
  default:
    log_e("Restarted because <unclassified reason>");
    break;
  }

  drd = new DoubleResetDetector(DRD_TIMEOUT, DRD_ADDRESS);
  if (drd->detectDoubleReset() && enter_reconfig)
  {
    log_i("Double Reset detected -> starting OTA mode");
    WiFi.softAP(ble_device_id, password);
    ArduinoOTA.setHostname(BLE_DEVICE_ID_PREFIX);
    ArduinoOTA.begin();
    unsigned long start = millis();

    // fading led to suggest status
    // Fade the activity led to suggest something is not right
    const int freq = 5000;
    const int ledChannel = 0;
    const int resolution = 8;
    ledcSetup(ledChannel, freq, resolution);
    ledcAttachPin(LED_STATUS, ledChannel);
    unsigned int dutyCycle = 0;

    // Wait OTA_TIMEOUT seconds, then restart
    while (millis() - start < (OTA_TIMEOUT * 1000))
    {
      ArduinoOTA.handle();
      drd->loop();
      ledcWrite(ledChannel, dutyCycle++);
      delay(2);
      if (dutyCycle > 255)
      {
        dutyCycle = 0;
      }
    }
    ESP.restart();
  }
  delay(1000);

  // Create the BLE Device
  NimBLEDevice::init(ble_device_id);
  // NimBLEDevice::setOwnAddrType(BLE_OWN_ADDR_RANDOM);
  // Optional: set the transmit power, default is 3db
  NimBLEDevice::setPower(ESP_PWR_LVL_P9);                             /** +9db */
  NimBLEDevice::setPower(ESP_PWR_LVL_P9, ESP_BLE_PWR_TYPE_ADV);       /** +9db */
  NimBLEDevice::setPower(ESP_PWR_LVL_P9, ESP_BLE_PWR_TYPE_CONN_HDL0); /** +9db */
  // NimBLEDevice::setMTU(185);
  // Adding bonding, so that we avoid picking up sensors from other nearby bikes unknownigly
  NimBLEDevice::setSecurityAuth(true, true, true);
  // NimBLEDevice::setSecurityAuth(/*BLE_SM_PAIR_AUTHREQ_BOND | BLE_SM_PAIR_AUTHREQ_MITM |*/ (uint8_t)BLE_SM_PAIR_AUTHREQ_SC);
  NimBLEDevice::setSecurityPasskey(BLE_SECURITY_PASS);
  NimBLEDevice::setSecurityIOCap(BLE_HS_IO_DISPLAY_ONLY);
  
  // Create the BLE Server
  pServer = NimBLEDevice::createServer();
  pServer->setCallbacks(new MyServerCallbacks());
  pServer->advertiseOnDisconnect(true);

  // Create the BLE Service
  NimBLEService *pService = pServer->createService(BLE_ENGINEDATA_SERVICE_UUID);

  // Create a BLE Characteristic - fast frequency messages
  pFastCharacteristic = pService->createCharacteristic(BLE_FAST_ENGINEDATA_CHARACTERISTIC_UUID,  NIMBLE_PROPERTY::READ | NIMBLE_PROPERTY::READ_ENC | NIMBLE_PROPERTY::READ_AUTHEN | NIMBLE_PROPERTY::NOTIFY);
  pFastCharacteristic->setCallbacks(&chrCallbacks);

  // Create a BLE Characteristic - slow frequency messages
  pSlowCharacteristic = pService->createCharacteristic(BLE_SLOW_ENGINEDATA_CHARACTERISTIC_UUID,  NIMBLE_PROPERTY::READ | NIMBLE_PROPERTY::READ_ENC | NIMBLE_PROPERTY::READ_AUTHEN | NIMBLE_PROPERTY::NOTIFY);
  pSlowCharacteristic->setCallbacks(&chrCallbacks);

    // Create a BLE Characteristic - write a true value to reboot the component
  pRebootCharacteristic = pService->createCharacteristic(BLE_REBOOT_CHARACTERISTIC_UUID, NIMBLE_PROPERTY::WRITE_NR);
  pRebootCharacteristic->setCallbacks(&chrCallbacks);

  // https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.descriptor.gatt.client_characteristic_configuration.xml

  // Start the service
  pService->start();

  // Start advertising
  NimBLEAdvertising *pAdvertising = NimBLEDevice::getAdvertising();
  // define appearance, from https://www.bluetooth.com/wp-content/uploads/Sitecore-Media-Library/Gatt/Xml/Characteristics/org.bluetooth.characteristic.gap.appearance.xml
  // TODO appearance: 1344-18 = 1362 sensor - multisensor https://specificationrefs.bluetooth.com/assigned-values/Appearance%20Values.pdf
  pAdvertising->setAppearance(1344); // this might crash esp32 ble stack
  pAdvertising->addServiceUUID(pService->getUUID());
  pAdvertising->setScanResponse(true);
  // pAdvertising->setScanResponse(false);
  // pAdvertising->setMinPreferred(0x06); // functions that help with iPhone connections issue -> find out more at https://github.com/h2zero/NimBLE-Arduino/issues/129
  // pAdvertising->setMinPreferred(0x0);  // set value to 0x00 to not advertise this parameter

  pAdvertising->start();
  log_i("Waiting a client connection to start notifications...");

  gpio_reset_pin(LED_STATUS);
  //  Set the GPIO as a push/pull output
  gpio_set_direction(LED_STATUS, GPIO_MODE_OUTPUT);
  gpio_set_level(LED_STATUS, LOW);

#if !defined(CAN_DATA_SIMULATOR_MODE)
  log_i("Setting up CANBUS");
  CAN.setPins(RX_GPIO_NUM, TX_GPIO_NUM);
  CAN.observe();
  // start the CAN bus at 500 kbps
  if (!CAN.begin(500E3))
  {
    log_e("Starting CAN failed!");
    // Fade the activity led to suggest something is not right
    int freq = 5000;
    int ledChannel = 0;
    int resolution = 8;
    ledcSetup(ledChannel, freq, resolution);
    ledcAttachPin(LED_STATUS, ledChannel);
    unsigned long InTenSeconds = millis() + 10000;

    while (millis() < InTenSeconds)
    {
      for (int dutyCycle = 0; dutyCycle <= 255; dutyCycle++)
      {
        ledcWrite(ledChannel, dutyCycle);
        delay(2);
      }

      for (int dutyCycle = 255; dutyCycle >= 0; dutyCycle--)
      {
        ledcWrite(ledChannel, dutyCycle);
        delay(2);
      }
    }
    // 10 seconds have passed, restart ESP32 and hope for better luck

    ESP.restart();
  }
  else
  {
    log_i("Connected to CANBUS");
  }
  CAN.onReceive(onReceive);
#else
  log_i("Running in simulation of CAN messages");
#endif // #if !defined(CAN_DATA_SIMULATOR_MODE)
  log_i("Starting main loop routine");
  tReport.enable();
}

// In the main loop we really don't do anything right now
void loop()
{
  ts.execute();
  drd->loop();
}

/* end of file */